/**
 * Copyright (C) 2011 - 2011, Vrai Stacey.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#include "cppwriter.hpp"
#include <stdexcept>

using namespace fudgeproto;

const std::string cppwriter::s_indent ( "    " );

cppwriter::cppwriter ( std::ostream & output, bool unsafe )
    : codewriter ( output, unsafe )
    , m_depth ( 0 )
{
}

const std::string & cppwriter::getIdLeaf ( const definition & def )
{
    return def.id ( ) [ def.id ( ).size ( ) - 1 ];
}

std::string cppwriter::generateTypeName ( const fieldtype & type )
{
    switch ( type.type ( ) )
    {
        case FUDGEPROTO_TYPE_BOOLEAN:  return "fudge_bool";
        case FUDGEPROTO_TYPE_BYTE:     return "fudge_byte";
        case FUDGEPROTO_TYPE_SHORT:    return "fudge_i16";
        case FUDGEPROTO_TYPE_INT:      return "fudge_i32";
        case FUDGEPROTO_TYPE_LONG:     return "fudge_i64";
        case FUDGEPROTO_TYPE_FLOAT:    return "fudge_f32";
        case FUDGEPROTO_TYPE_DOUBLE:   return "fudge_f64";
        case FUDGEPROTO_TYPE_STRING:   return "fudge::string";
        case FUDGEPROTO_TYPE_MESSAGE:  return "fudge::message";
        case FUDGEPROTO_TYPE_DATE:     return "fudge::date";
        case FUDGEPROTO_TYPE_TIME:     return "fudge::time";
        case FUDGEPROTO_TYPE_DATETIME: return "fudge::datetime";
        case FUDGEPROTO_TYPE_USER:     return generateIdString ( type.name ( ) );
        default:
            throw std::invalid_argument ( "Unsupported type for C++ writer" );
    }
}

std::string cppwriter::generateIndent ( ) const
{
    std::string indent;
    for ( size_t index ( 0 ); index < m_depth; ++index )
        indent += s_indent;
    return indent;
}

std::string cppwriter::generateHeader ( ) const
{
    std::string output =
        "/**\n"
        " * Code generated by SimpleFudgeProto, a Fudge/C++ code generate\n"
        " * that uses protobuf like defintion files.\n"
        " *\n"
        " * Copyright (C) 2011 - 2011, Vrai Stacey.\n"
        " *\n"
        " * Licensed under the Apache License, Version 2.0 (the \"License\");\n"
        " * you may not use this file except in compliance with the License.\n"
        " * You may obtain a copy of the License at\n"
        " *\n"
        " *     http://www.apache.org/licenses/LICENSE-2.0\n"
        " *\n"
        " * Unless required by applicable law or agreed to in writing, software\n"
        " * distributed under the License is distributed on an \"AS IS\" BASIS,\n"
        " * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n"
        " * See the License for the specific language governing permissions and\n"
        " * limitations under the License.\n"
        " */\n";

    if ( m_unsafe )
        output += "\n/**\n"
        " * Code generated with unsafe flag set, object type fields will not be\n"
        " * checked when decoding messages.\n"
        " */\n";

    return output;
}

std::string cppwriter::generateIdString ( const identifier & id )
{
    return id.asString ( "::" );
}

std::string cppwriter::generateMemberName ( const fielddef & field )
{
    return "m_" + getIdLeaf ( field );
}

std::string cppwriter::generateTrueType ( const fielddef & field )
{
    const bool isCollection ( field.isCollection ( ) );
    const bool isSimples ( ! field.type ( ).isComplex ( ) );

    std::string type;
    if ( isSimples && ! isCollection )
        type = generateTypeName ( field.type ( ) );
    else
    {
        type = generateStorageType ( field );
        if ( ! isCollection && ! isSimples ) type += "*";
    }
    return type;
}

std::string cppwriter::generateMemberType ( const fielddef & field )
{
    const std::string type ( generateTrueType ( field ) );

    if ( field.isOptional ( ) && ( field.isCollection ( ) || ! field.type ( ).isComplex ( ) ) )
        return "fudge::optional< " + type + " >";
    else
        return type;
}

std::string cppwriter::generateArgType ( const fielddef & field )
{
    const bool isCollection ( field.isCollection ( ) );
    const bool isSimples ( ! field.type ( ).isComplex ( ) );
    const bool isConst ( isCollection );

    std::string type;
    if ( isSimples && ! isCollection )
        type = generateTypeName ( field.type ( ) );
    else
    {
        if ( isConst && ! field.isOptional ( ) )
            type += "const ";

        type += generateStorageType ( field );

        if ( isCollection )
        {
            if ( ! field.isOptional ( ) )
                type += "&";
        }
        else
        {
            if ( ! field.isOptional ( ) || ! isSimples )
                type += "*";
        }
    }

    if ( field.isOptional ( ) && ( isSimples || isCollection ) )
        type = "const fudge::optional< " + type + " > &";

    return type;
}

std::string cppwriter::escapeString ( const std::string & string )
{
    std::string newstring;
    newstring.reserve ( string.size ( ) * 2 );
    for ( std::string::const_iterator it ( string.begin ( ) ); it < string.end ( ); ++it )
    {
        switch ( *it )
        {
            case '\n':  newstring.append ( "\\n" ); break;
            case '\r':  newstring.append ( "\\r" ); break;
            case '\t':  newstring.append ( "\\t" ); break;
            case '\b':  newstring.append ( "\\b" ); break;

            case '\"':
            case '\\':
                newstring.push_back ( '\\' );
                newstring.push_back ( *it );
                break;

            default:
                if ( *it >= ' ' )
                    newstring.push_back ( *it );
        }
    }
    return newstring;
}

std::string cppwriter::generateStorageType ( const fielddef & field )
{
    std::string name ( generateTypeName ( field.type ( ) ) );
    if ( field.isCollection ( ) )
    {
        if ( field.type ( ).isComplex ( ) ) name += "*";

        for ( size_t index ( 0 ); index < field.constraints ( ).size ( ); ++index )
            name = "std::vector< " + name + " >";
    }
    return name;

}

